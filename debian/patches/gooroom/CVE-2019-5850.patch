commit 2914cfb4789e72ba5318f1aae06be36b0eed6c2b
Author: Dan Harrington <harringtond@chromium.org>
Date:   Mon Jul 8 17:37:33 2019 +0000

    Fix crash in OfflinePageAutoFetcher
    
    Lifetime of RenderFrameHost was not properly maintained.
    
    Bug: 977462
    
    Change-Id: I66c16fa397a42c778b22bb1ad8909a3b1cf1b41f
    Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1679551
    Commit-Queue: Dan H <harringtond@chromium.org>
    Reviewed-by: Cathy Li <chili@chromium.org>
    Reviewed-by: Jonathan Metzman <metzman@chromium.org>
    Cr-Commit-Position: refs/heads/master@{#675278}

diff --git a/chrome/browser/offline_pages/android/offline_page_auto_fetcher.cc b/chrome/browser/offline_pages/android/offline_page_auto_fetcher.cc
index 7242d524dfac..0dfd12c215d7 100644
--- a/chrome/browser/offline_pages/android/offline_page_auto_fetcher.cc
+++ b/chrome/browser/offline_pages/android/offline_page_auto_fetcher.cc
@@ -40,38 +40,45 @@ TabAndroid* FindTab(content::RenderFrameHost* render_frame_host) {
 
 OfflinePageAutoFetcher::OfflinePageAutoFetcher(
     content::RenderFrameHost* render_frame_host)
-    : render_frame_host_(render_frame_host) {}
+    : last_committed_url_(render_frame_host->GetLastCommittedURL()) {
+  TabAndroid* tab = FindTab(render_frame_host);
+  if (!tab) {
+    return;
+  }
+  auto_fetcher_service_ =
+      OfflinePageAutoFetcherServiceFactory::GetForBrowserContext(
+          render_frame_host->GetProcess()->GetBrowserContext());
+  android_tab_id_ = tab->GetAndroidId();
+}
 
 OfflinePageAutoFetcher::~OfflinePageAutoFetcher() = default;
 
 void OfflinePageAutoFetcher::TrySchedule(bool user_requested,
                                          TryScheduleCallback callback) {
-  TabAndroid* tab = FindTab(render_frame_host_);
-  if (!tab) {
+  if (!auto_fetcher_service_) {
     std::move(callback).Run(OfflinePageAutoFetcherScheduleResult::kOtherError);
     return;
   }
-  GetService()->TrySchedule(user_requested,
-                            render_frame_host_->GetLastCommittedURL(),
-                            tab->GetAndroidId(), std::move(callback));
+
+  auto_fetcher_service_->TrySchedule(user_requested, last_committed_url_,
+                                     android_tab_id_, std::move(callback));
 }
 
 void OfflinePageAutoFetcher::CancelSchedule() {
-  GetService()->CancelSchedule(render_frame_host_->GetLastCommittedURL());
+  if (!auto_fetcher_service_)
+    return;
+  auto_fetcher_service_->CancelSchedule(last_committed_url_);
 }
 
 // static
 void OfflinePageAutoFetcher::Create(
     chrome::mojom::OfflinePageAutoFetcherRequest request,
     content::RenderFrameHost* render_frame_host) {
+  // Lifetime of the strong binding can exceed the render frame host, so
+  // OfflinePageAutoFetcher does not retain a reference.
   mojo::MakeStrongBinding(
       std::make_unique<OfflinePageAutoFetcher>(render_frame_host),
       std::move(request));
 }
 
-OfflinePageAutoFetcherService* OfflinePageAutoFetcher::GetService() {
-  return OfflinePageAutoFetcherServiceFactory::GetForBrowserContext(
-      render_frame_host_->GetProcess()->GetBrowserContext());
-}
-
 }  // namespace offline_pages
diff --git a/chrome/browser/offline_pages/android/offline_page_auto_fetcher.h b/chrome/browser/offline_pages/android/offline_page_auto_fetcher.h
index e39387abd787..a7ca7c470b3b 100644
--- a/chrome/browser/offline_pages/android/offline_page_auto_fetcher.h
+++ b/chrome/browser/offline_pages/android/offline_page_auto_fetcher.h
@@ -38,7 +38,9 @@ class OfflinePageAutoFetcher : public chrome::mojom::OfflinePageAutoFetcher {
   using OfflinePageAutoFetcherScheduleResult =
       chrome::mojom::OfflinePageAutoFetcherScheduleResult;
 
-  content::RenderFrameHost* render_frame_host_;
+  GURL last_committed_url_;
+  int android_tab_id_;
+  OfflinePageAutoFetcherService* auto_fetcher_service_ = nullptr;
 };
 
 }  // namespace offline_pages
diff --git a/chrome/renderer/net/net_error_helper_core.cc b/chrome/renderer/net/net_error_helper_core.cc
index cb2ad2d5edd5..9dff86e4db38 100644
--- a/chrome/renderer/net/net_error_helper_core.cc
+++ b/chrome/renderer/net/net_error_helper_core.cc
@@ -572,6 +572,7 @@ void NetErrorHelperCore::OnCommitLoad(FrameType frame_type, const GURL& url) {
   // Don't need this state. It will be refreshed if another error page is
   // loaded.
   available_content_helper_.Reset();
+  page_auto_fetcher_helper_->OnCommitLoad();
 #endif
 
   // Track if an error occurred due to a page button press.
diff --git a/chrome/renderer/net/net_error_helper_core_unittest.cc b/chrome/renderer/net/net_error_helper_core_unittest.cc
index 3885911ad4a1..8774272110ce 100644
--- a/chrome/renderer/net/net_error_helper_core_unittest.cc
+++ b/chrome/renderer/net/net_error_helper_core_unittest.cc
@@ -21,6 +21,7 @@
 #include "base/stl_util.h"
 #include "base/strings/string_util.h"
 #include "base/strings/stringprintf.h"
+#include "base/test/bind_test_util.h"
 #include "base/test/metrics/histogram_tester.h"
 #include "base/test/scoped_task_environment.h"
 #include "base/timer/mock_timer.h"
@@ -2762,11 +2763,17 @@ class FakeOfflinePageAutoFetcher
 class TestPageAutoFetcherHelper : public PageAutoFetcherHelper {
  public:
   explicit TestPageAutoFetcherHelper(
-      chrome::mojom::OfflinePageAutoFetcherPtr fetcher)
-      : PageAutoFetcherHelper(nullptr) {
-    fetcher_ = std::move(fetcher);
+      base::RepeatingCallback<chrome::mojom::OfflinePageAutoFetcherPtr()>
+          binder)
+      : PageAutoFetcherHelper(nullptr), binder_(binder) {}
+  bool Bind() override {
+    if (!fetcher_)
+      fetcher_ = binder_.Run();
+    return true;
   }
-  bool Bind() override { return true; }
+
+ private:
+  base::RepeatingCallback<chrome::mojom::OfflinePageAutoFetcherPtr()> binder_;
 };
 
 // Provides set up for testing the 'auto fetch on dino' feature.
@@ -2783,12 +2790,16 @@ class NetErrorHelperCoreAutoFetchTest : public NetErrorHelperCoreTest {
         chrome::mojom::OfflinePageAutoFetcher::Name_,
         base::BindRepeating(&FakeOfflinePageAutoFetcher::AddBinding,
                             base::Unretained(&fake_fetcher_)));
-    chrome::mojom::OfflinePageAutoFetcherPtr fetcher_ptr;
-    render_thread()->GetConnector()->BindInterface(
-        content::mojom::kBrowserServiceName, &fetcher_ptr);
-    ASSERT_TRUE(fetcher_ptr);
+
+    auto binder = base::BindLambdaForTesting([&]() {
+      chrome::mojom::OfflinePageAutoFetcherPtr fetcher_ptr;
+      render_thread()->GetConnector()->BindInterface(
+          content::mojom::kBrowserServiceName, &fetcher_ptr);
+      return fetcher_ptr;
+    });
+
     core()->SetPageAutoFetcherHelperForTesting(
-        std::make_unique<TestPageAutoFetcherHelper>(std::move(fetcher_ptr)));
+        std::make_unique<TestPageAutoFetcherHelper>(binder));
   }
 
  protected:
diff --git a/chrome/renderer/net/page_auto_fetcher_helper_android.cc b/chrome/renderer/net/page_auto_fetcher_helper_android.cc
index 7705c0db661a..e36ec01a1a32 100644
--- a/chrome/renderer/net/page_auto_fetcher_helper_android.cc
+++ b/chrome/renderer/net/page_auto_fetcher_helper_android.cc
@@ -18,6 +18,12 @@ PageAutoFetcherHelper::PageAutoFetcherHelper(content::RenderFrame* render_frame)
     : render_frame_(render_frame) {}
 PageAutoFetcherHelper::~PageAutoFetcherHelper() = default;
 
+void PageAutoFetcherHelper::OnCommitLoad() {
+  // Make sure we don't try to re-use the same mojo interface for more than one
+  // page. Otherwise, the browser side will use the old page's URL.
+  fetcher_.reset();
+}
+
 void PageAutoFetcherHelper::TrySchedule(
     bool user_requested,
     base::OnceCallback<void(FetcherScheduleResult)> complete_callback) {
diff --git a/chrome/renderer/net/page_auto_fetcher_helper_android.h b/chrome/renderer/net/page_auto_fetcher_helper_android.h
index 0d76567f18f5..f250510c18d3 100644
--- a/chrome/renderer/net/page_auto_fetcher_helper_android.h
+++ b/chrome/renderer/net/page_auto_fetcher_helper_android.h
@@ -22,6 +22,8 @@ class PageAutoFetcherHelper {
       chrome::mojom::OfflinePageAutoFetcherScheduleResult;
   explicit PageAutoFetcherHelper(content::RenderFrame* render_frame);
   virtual ~PageAutoFetcherHelper();
+  // Should be called for each page load.
+  void OnCommitLoad();
   void TrySchedule(
       bool user_requested,
       base::OnceCallback<void(FetcherScheduleResult)> complete_callback);
