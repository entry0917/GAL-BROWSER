From 6b96a757e8b32e1248268423c39bed013a72ee05 Mon Sep 17 00:00:00 2001
From: junsungc <junsungc@gooroom.kr>
Date: Fri, 6 Sep 2019 11:14:08 +0900
Subject: [PATCH 69/78] gooroom-security-utils migrated into gooroom-browser

---
 gooroom/browser/BUILD.gn            |  17 ++-
 gooroom/browser/gooroom_pref.cc     | 200 +++++++++++++++++++-----
 gooroom/browser/verify_signature.cc | 228 +++++++++++++++-------------
 gooroom/browser/verify_signature.h  |  34 ++---
 4 files changed, 308 insertions(+), 171 deletions(-)

diff --git a/gooroom/browser/BUILD.gn b/gooroom/browser/BUILD.gn
index 878fad7f4ecc..4c4edf6499d9 100644
--- a/gooroom/browser/BUILD.gn
+++ b/gooroom/browser/BUILD.gn
@@ -1,14 +1,16 @@
 import("//chrome/chrome_paks.gni")
 import("//build/util/branding.gni")
+import("//build/config/linux/pkg_config.gni")
 
-static_library("gooroom_browser") {
-  if (host_cpu != "arm") {
-    libs = [ "/usr/lib/x86_64-linux-gnu/libgrmpycaller.so"]
-    libs += [ "/usr/lib/x86_64-linux-gnu/libcrypto.so.1.1" ]
-  } else {
-    libs = [ "/usr/lib/arm-linux-gnueabihf/libcrypto.so.1.1" ]
-  }
+pkg_config("signverify") {
+  packages = [
+    "libssl",
+    "openssl",
+    "python3",
+  ]
+}
 
+static_library("gooroom_browser") {
   sources = [
     "gooroom_browser_extra_parts_security.cc",
     "gooroom_browser_extra_parts_security.h",
@@ -28,6 +30,7 @@ static_library("gooroom_browser") {
     "odf/odf_extension_util.h",
   ]
 
+  public_configs = [ ":signverify" ]
   deps = [
     "//chrome/browser:browser",
     "//build/config/linux/gtk",
diff --git a/gooroom/browser/gooroom_pref.cc b/gooroom/browser/gooroom_pref.cc
index a5c5d2760807..69384cadf89f 100644
--- a/gooroom/browser/gooroom_pref.cc
+++ b/gooroom/browser/gooroom_pref.cc
@@ -3,6 +3,7 @@
 #include <fstream>
 #include <gtk/gtk.h>
 
+#include "verify_signature.h"
 #include "base/files/file_enumerator.h"
 #include "verify_signature.h"
 #include "gooroom/base/gooroom_base.h"
@@ -23,6 +24,8 @@
 #include "components/prefs/pref_service.h"
 #include "components/prefs/pref_service_factory.h"
 
+#define LOCAL_USER                      0
+
 namespace gooroom {
 
 using std::string;
@@ -33,19 +36,173 @@ bool is_file_exist(const char *fileName)
     return infile.good();
 }
 
+void noVerifySignAlarm() {
+    GtkWidget *window;
+    GtkWidget *label;
+
+    /* Create the main, top level window */
+    window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
+
+    /* Give it the title */
+    gtk_window_set_title(GTK_WINDOW(window), "Info Bars");
+    gtk_window_set_default_size(GTK_WINDOW(window), 230, 50);
+
+    /*
+    ** Map the destroy signal of the window to gtk_main_quit;
+    ** When the window is about to be destroyed, we get a notification and
+    ** stop the main GTK+ loop by returning 0
+    */
+    g_signal_connect(window, "destroy", G_CALLBACK(gtk_main_quit), NULL);
+
+    label = gtk_label_new("Gooroom-Browser : No sign verify. Check gooroom-agent service.");
+
+    /* Plot the label onto the main window */
+    gtk_container_add(GTK_CONTAINER(window), label);
+
+    /* Make sure that everything, window and label, are visible */
+    gtk_widget_show_all(window);
+
+    /*
+    ** Start the main loop, and do nothing (block) until
+    ** the application is closed
+    */
+    gtk_main();
+}
+
+int is_local_user() {
+  FILE *fp = NULL;
+  char input[1024];
+  int sessionNum=0;
+  int userID=0;
+  bool service_lightdm = false;
+  bool state_active = false;
+  bool active_yes = false;
+
+  if((fp = popen("loginctl list-sessions", "r")) == NULL) {
+    return 0;
+  }
+
+  std::vector<std::string> lines;
+  while (fgets(input, 1024, fp) != NULL) {
+    lines.push_back(input);
+  }
+  pclose(fp);
+  for(int i=0;i<lines.size();i++) {
+    char *len = new char[128];
+    strcpy(len, lines.at(i).c_str());
+
+    int num=0;
+    char *tok = strtok(len, " ");
+    while (tok != nullptr ) {
+      if (num==0 || num==1 ) {
+        if (!atoi(tok))
+          break;
+      }
+      if (num==0 && sessionNum==0)
+        sessionNum=atoi(tok);
+      if (num==1 && userID==0)
+        userID=atoi(tok);
+      if (num==2) {
+        FILE *fp2 = NULL;
+        char buf[128];
+        sprintf(buf, "loginctl show-session %d", sessionNum);
+        if((fp2 = popen(buf, "r")) == NULL) {
+          return 0;
+        }
+        std::vector<std::string> lines2;
+        while(fgets(input, 1024, fp2) != NULL) {
+          lines2.push_back(input);
+        }
+        pclose(fp2);
+        for(int i=0; i<lines2.size(); i++) {
+          char *len2 = new char[128];
+          strcpy(len2, lines2.at(i).c_str());
+          char *tok2 = strtok(len2, "=");
+          if (strcmp(tok2, "Id") == 0) {
+            tok2 = strtok(nullptr, "=");
+            if (!atoi(tok2)==sessionNum)
+              break;
+            else
+              continue;
+          }
+          if (strcmp(tok2, "User") == 0) {
+            tok2 = strtok(nullptr, "=");
+            if (!atoi(tok2)==userID)
+              break;
+            else
+              continue;
+          }
+          if (strcmp(tok2, "Name") == 0) {
+            tok2 = strtok(nullptr, "=");
+            tok2 = strtok(tok2,"\n");
+            if (strcmp(tok2,tok) == 0)
+              continue;
+            else
+              break;
+          }
+          if (strcmp(tok2, "Service") == 0) {
+            tok2 = strtok(nullptr, "=");
+            tok2 = strtok(tok2, "\n");
+            if (strcmp(tok2, "lightdm") == 0) {
+              service_lightdm = true;
+              continue;
+            }
+            else
+              break;
+          }
+          if (strcmp(tok2, "State") == 0) {
+            tok2 = strtok(nullptr, "=");
+            tok2 = strtok(tok2, "\n");
+            if (strcmp(tok2, "active") == 0) {
+              state_active = true;
+              continue;
+            }
+            else
+              break;
+          }
+          if (strcmp(tok2, "Active") == 0) {
+            tok2 = strtok(nullptr, "=");
+            tok2 = strtok(tok2, "\n");
+            if (strcmp(tok2, "yes") == 0){
+              active_yes = true;
+              continue;
+            }
+            else
+              break;
+          }
+          if (service_lightdm && state_active && active_yes){
+            sprintf(buf, "/var/run/user/%d/gooroom/.grm-user", userID);
+            struct stat tmp;
+            if (stat(buf, &tmp) == 0){
+              return 0;
+            }
+            else {
+              return 1;
+            }
+          }
+        }
+      }
+      tok = strtok(nullptr, " ");
+      num++;
+    }
+  }
+  return 0;
+}
+
 // verify a sing is valid
 bool verifySign() {
   int ret_code;
   int i;
-  ret_code = is_onlineuser();
-  if (ret_code == LOCAL_USER) {
+  bool validSign = true;
+  if (is_local_user()) {
+    ret_code = LOCAL_USER;
     char buff[100] = {0,};
     snprintf(buff, sizeof(buff), "SIGN verified ret_code=$(%d)", ret_code);
     SYSLOG(INFO) << buff << " GRMCODE=050001";
     SYSLOG(INFO) << "SIGN verified ok GRMCODE=050002";
     return true;
   }
-  bool validSign = true;
+
   string* verifySignDir = new string[5] { "/usr/share/gooroom/browser/policies/mainpref.json",
                                        "/usr/share/gooroom/browser/policies/trust/managed/policy.json",
                                        "/usr/share/gooroom/browser/policies/trust/managed/ui-policy.json",
@@ -81,39 +238,6 @@ bool verifySign() {
   return validSign;
 }
 
-void noVerifySignAlarm() {
-    GtkWidget *window;
-    GtkWidget *label;
-
-    /* Create the main, top level window */
-    window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
-
-    /* Give it the title */
-    gtk_window_set_title(GTK_WINDOW(window), "Info Bars");
-    gtk_window_set_default_size(GTK_WINDOW(window), 230, 50);
-
-    /*
-    ** Map the destroy signal of the window to gtk_main_quit;
-    ** When the window is about to be destroyed, we get a notification and
-    ** stop the main GTK+ loop by returning 0
-    */
-    g_signal_connect(window, "destroy", G_CALLBACK(gtk_main_quit), NULL);
-
-    label = gtk_label_new("Gooroom-Browser : No sign verify. Check gooroom-agent service.");
-
-    /* Plot the label onto the main window */
-    gtk_container_add(GTK_CONTAINER(window), label);
-
-    /* Make sure that everything, window and label, are visible */
-    gtk_widget_show_all(window);
-
-    /*
-    ** Start the main loop, and do nothing (block) until
-    ** the application is closed
-    */
-    gtk_main();
-}
-
 GooroomPref* g_gooroom = NULL;
 
 GooroomPref::GooroomPref() {}
@@ -239,8 +363,8 @@ void GooroomPref::setup() {
   // Gooroom-Browser policy Sign module
   bool validSign = verifySign();
   if (!validSign) {
-    //noVerifySignAlarm();
-    //exit(0);
+    noVerifySignAlarm();
+    exit(0);
   }
 
   // Check policies files
diff --git a/gooroom/browser/verify_signature.cc b/gooroom/browser/verify_signature.cc
index a848ecacc49f..0c0354f2216f 100644
--- a/gooroom/browser/verify_signature.cc
+++ b/gooroom/browser/verify_signature.cc
@@ -1,19 +1,32 @@
-//-----------------------------------------------------------------------
+/*
+ * Copyright (C) 2015-2017 Gooroom <gooroom@gooroom.kr>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
+ */
+
 #include <openssl/aes.h>
 #include <openssl/evp.h>
 #include <openssl/rsa.h>
 #include <openssl/pem.h>
 #include <openssl/ssl.h>
-#include <openssl/bio.h>
 #include <openssl/err.h>
-#include <sys/types.h>
 #include <sys/stat.h>
-#include <string.h>
-#include <unistd.h>
-#include <stdio.h>
-#include <fcntl.h>
-#include <utmp.h>
-#include <pwd.h>
+
+#include <Python.h>
+#include <stdlib.h>
+#include <stdint.h>
 
 #include "verify_signature.h"
 
@@ -21,81 +34,63 @@
 const char *g_cert_path = "/etc/gooroom/agent/server_certificate.crt";
 const char *g_signature_path = "/var/tmp/gooroom-agent-service/";
 
-//-----------------------------------------------------------------------
-static int get_loginid(char *loginid, int idlen)
+/*------ Base64 Decoding Table ------*/
+static int DecodeMimeBase64[256] = {
+    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 00-0F */
+    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 10-1F */
+    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62,-1,-1,-1,63,  /* 20-2F */
+    52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-1,-1,-1,  /* 30-3F */
+    -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,  /* 40-4F */
+    15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,  /* 50-5F */
+    -1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,  /* 60-6F */
+    41,42,43,44,45,46,47,48,49,50,51,-1,-1,-1,-1,-1,  /* 70-7F */
+    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 80-8F */
+    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 90-9F */
+    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* A0-AF */
+    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* B0-BF */
+    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* C0-CF */
+    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* D0-DF */
+    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* E0-EF */
+    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1   /* F0-FF */
+    };
+int base64_decode(char *text, unsigned char *dst, int numBytes )
 {
-    if (!loginid) {
-        return LOGINID_PARAMETER_NULL;
-    }
-
-    struct utmp w;
-    int fd = open("/var/run/utmp", O_RDONLY); 
-
-    if(fd < 0) { 
-        return LOGINID_FAILED_OPEN_UTMP;
-    }
-
-    while (read(fd, &w, sizeof(w)) > 0) {
-        if (w.ut_type == 7 && !strcmp(w.ut_id, ":0")) {
-            snprintf(loginid, idlen, "%s", w.ut_user);
-            close(fd);
-            return LOGINID_SUCCESS;
+  const char* cp;
+  int space_idx = 0, phase;
+  int d, prev_d = 0;
+  unsigned char c;
+    space_idx = 0;
+    phase = 0;
+    for ( cp = text; *cp != '\0'; ++cp ) {
+        d = DecodeMimeBase64[(int) *cp];
+        if ( d != -1 ) {
+            switch ( phase ) {
+                case 0:
+                    ++phase;
+                    break;
+                case 1:
+                    c = ( ( prev_d << 2 ) | ( ( d & 0x30 ) >> 4 ) );
+                    if ( space_idx < numBytes )
+                        dst[space_idx++] = c;
+                    ++phase;
+                    break;
+                case 2:
+                    c = ( ( ( prev_d & 0xf ) << 4 ) | ( ( d & 0x3c ) >> 2 ) );
+                    if ( space_idx < numBytes )
+                        dst[space_idx++] = c;
+                    ++phase;
+                    break;
+                case 3:
+                    c = ( ( ( prev_d & 0x03 ) << 6 ) | d );
+                    if ( space_idx < numBytes )
+                        dst[space_idx++] = c;
+                    phase = 0;
+                    break;
+            }
+            prev_d = d;
         }
     }
-
-    close(fd);
-    return LOGINID_NOT_LOGIN;
-}
-
-//-----------------------------------------------------------------------
-int is_onlineuser()
-{
-    char loginid[64] = { 0, };
-    int ret_code = get_loginid(loginid, sizeof(loginid));
-    if (ret_code < 0) {
-        return ret_code;
-    }
-
-    int online_in_passwd = 0;
-    struct passwd *pd;
-    while ((pd = getpwent())) {
-        if (!strcmp(pd->pw_name, loginid) && strstr(pd->pw_gecos, "gooroom-online-account")) {
-            online_in_passwd = 1;
-            break;
-        }
-    }
-    if (!online_in_passwd) return LOCAL_USER;
-
-    char grmuser_path[128] = { 0, };
-    snprintf(grmuser_path, sizeof(grmuser_path), "/var/run/user/%d/gooroom/.grm-user", pd->pw_uid);
-    if (access(grmuser_path, F_OK)) return LOCAL_USER;
-
-    return ONLINE_USER;
-}
-
-//-----------------------------------------------------------------------
-static void decode_base64(
-    char *text, unsigned char **decoded_text, size_t *decoded_text_len)
-{
-    //calc text's length to decode
-    size_t text_len = strlen(text);
-    size_t padding = 0;
-
-    if (text[text_len-1] == '=' && text[text_len-2] == '=')
-        padding = 2;
-    else if (text[text_len-1] == '=')
-        padding = 1;
-
-    int decoding_text_len = (text_len*3)/4 - padding;
-
-    //decode
-    *decoded_text = (unsigned char*)calloc(1, decoding_text_len + 1);
-    BIO *bio = BIO_new_mem_buf(text, -1);
-    BIO *b64 = BIO_new(BIO_f_base64());
-    bio = BIO_push(b64, bio);
-    *decoded_text_len = BIO_read(bio, *decoded_text, strlen(text));
-
-    BIO_free_all(bio);
+    return space_idx;
 }
 
 //-----------------------------------------------------------------------
@@ -125,7 +120,7 @@ ERR_0:
 }
 
 //-----------------------------------------------------------------------
-static int _verify_signature_deprecated(
+static int _verify_signature(
     const char *cert_path, const char *data, char *signature) 
 {
     //make rsa public key
@@ -133,9 +128,9 @@ static int _verify_signature_deprecated(
     if (!evp_key) return READ_PUBKEY_FROM_CERT_ERROR;
 
     //decode signature from base64
-    unsigned char *decoded_signature;
-    size_t decoded_signature_len;
-    decode_base64(signature, &decoded_signature, &decoded_signature_len);
+    int siglen = strlen(signature);
+    unsigned char *decoded_signature = (unsigned char*)malloc(siglen);
+    size_t decoded_signature_len = base64_decode(signature, decoded_signature, siglen);
 
     //verify
     EVP_MD_CTX *evp_ctx = EVP_MD_CTX_create();
@@ -155,7 +150,7 @@ static int _verify_signature_deprecated(
     }
 
 CLEANUP:
-    EVP_MD_CTX_cleanup(evp_ctx);
+    EVP_MD_CTX_free(evp_ctx);
     free(decoded_signature);
     EVP_PKEY_free(evp_key);
 
@@ -193,7 +188,7 @@ static void replace_slash_dot(char *path)
 
 //-----------------------------------------------------------------------
 #define TRIVIAL_LEN 4096
-int verify_signature_deprecated(const char *file_path)
+int verify_signature(const char *file_path) 
 {
     //read file
     FILE *fp = fopen(file_path, "r");
@@ -228,32 +223,53 @@ int verify_signature_deprecated(const char *file_path)
     fclose(fp);
 
     //do
-    int ret_code = _verify_signature_deprecated(g_cert_path, text, signature);
+    int ret_code = _verify_signature(g_cert_path, text, signature);
     free(text);
     free(sig_dir);
     return ret_code; 
 }
 
-#if DEBUG
-//-----------------------------------------------------------------------
-//sudo apt install libssl-dev
-//gcc -g -DDEBUG -o verify_signature verify_signature.c -lcrypto -lssl
-
 //-----------------------------------------------------------------------
-int main()
+char*
+do_task(const char *task)
 {
-    int ret_code = verify_signature(
-        "/etc/apt/sources.list.d/official-package-repositories.list");
+    PyObject *module_name, *module, *func, *args, *value;
+	char *char_value, *return_value = NULL;
+	Py_ssize_t value_size = 0;
 
-    if (ret_code == VERIFY_SUCCESS) {
-        printf("VERIFY SUCCESS\n");
-    }
-    else {
-        printf("VERIFY FAILURE\n");
-    }
+    putenv(PYTHONPATH);
 
-    printf("ret_code=%d\n", ret_code);
-    return 0;
-}
-#endif //DEBUG
+    Py_Initialize();
+
+    module_name = PyUnicode_FromString(MODULE_NAME);
+    module = PyImport_Import(module_name);
+    Py_DECREF(module_name);
+
+	if (module == NULL) goto ERR_MODULE;
+
+	func = PyObject_GetAttrString(module, FUNC_NAME);
+	if (!func) goto ERR_FUNCTION;
+
+	args = PyTuple_New(1);
+	value = PyUnicode_FromString(task);
+	PyTuple_SetItem(args, 0, value);
 
+	value = PyObject_CallObject(func, args);
+	Py_DECREF(args);
+	if (!value) goto ERR_CALL;
+
+	char_value = PyUnicode_AsUTF8AndSize(value, &value_size);
+	return_value = (char *)calloc(1, value_size+1);
+	memcpy(return_value, char_value, value_size);
+
+    Py_DECREF(value);
+
+ERR_CALL:
+    Py_DECREF(func);
+ERR_FUNCTION:
+    Py_DECREF(module);
+ERR_MODULE:
+   	Py_Finalize();
+
+	return return_value;
+}
diff --git a/gooroom/browser/verify_signature.h b/gooroom/browser/verify_signature.h
index 4bef22d2156e..1d39225291f4 100644
--- a/gooroom/browser/verify_signature.h
+++ b/gooroom/browser/verify_signature.h
@@ -1,30 +1,24 @@
-#ifndef VERIFY_SIGNATURE_H
-#define VERIFY_SIGNATURE_H
+#ifndef PYCALLER_H
+#define PYCALLER_H
 
-#define LOGINID_SUCCESS                 0
-
-#define LOCAL_USER                      0
-#define ONLINE_USER                     1
-
-#define VERIFY_NO_NEED                  1
 #define VERIFY_SUCCESS                  0
-
-#define DIGEST_VERIFY_FINAL_ERROR       -1
-
-#define DIGEST_VERIFY_UPDATE_ERROR      -2
+#define FILE_OPEN_ERROR                 -1
+#define READ_PUBKEY_FROM_CERT_ERROR     -2
 #define DIGEST_VERIFY_INIT_ERROR        -3
-#define READ_PUBKEY_FROM_CERT_ERROR     -4
-#define FILE_OPEN_ERROR                 -5
-#define LOGINID_NOT_LOGIN               -6
-#define LOGINID_FAILED_OPEN_UTMP        -7
-#define LOGINID_PARAMETER_NULL          -8
+#define DIGEST_VERIFY_UPDATE_ERROR      -4
+#define DIGEST_VERIFY_FINAL_ERROR       -5
 
+#define PYTHONPATH  "PYTHONPATH=/usr/lib/gooroom-security-utils/pycaller/"
+#define MODULE_NAME "pycaller"
+#define FUNC_NAME "do_task"
 #ifdef __cplusplus
-extern "C" int is_onlineuser();
-extern "C" int verify_signature(const char *file_path);
+extern "C" {
+int verify_signature(const char *file_path);
+char* do_task(const char *task);
+}
 #else
-int is_onlineuser();
 int verify_signature(const char *file_path);
+char* do_task(const char *task);
 #endif //__cplusplus
 
 #endif //VERIFY_SIGNATURE_H
-- 
2.20.1

